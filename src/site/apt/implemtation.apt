How To Implement using Objex

  This page details how to implement Objex. The examples of this page all
  make use of the Spring Roo based generators provided with Objex, this
  reduces the amount of boiler plate code you have to write. A future page
  will elaborate and detail the boiler plate code - or you can look at the
  ITDs generated by Objex to see the detail.
  
** Scenario

  In this example we are going to implement the one of the containers in the
  sample provided as part of Objex. Specifically we are going to create a 
  container that represents an Order from a customer.
  
** Object Model

  The following class diagram depicts the class model we are going to produce:
  
  << To-do: The Object Model >>
  
** Steps

  Before we go on, lets just review the steps we are going to make:
  
  [[1]] Create our Project and get Roo working
  
  [[2]] Create the state beans that represent our persistable state
  
  [[3]] Create the ObjexObj objects that represent the behaviour and the
  public face of the objects.
  
  [[4]] Describe the Container and it's Objects so that default container
  and factory instances can use it.
  
  [[5]] Test our Container using the simple in-memory runtime environment
  
  [[6]] Create and implement traditional Domain Service and Repository 
  interfaces so we can completely hide all Objex artefacts from our clients.
  
** Step 1 - Create the Project

  An Objex Container will be implemented inside a project that produces a
  JAR archive - so a simple Maven project will suffice. You may elect to
  produce each container in it's own project so they can evolve separately
  more easily, although in the samples that are part of Object we implement
  multiple containers inside 1 project.
  
  You can just create a simple Maven project, but because there are some
  dependencies on Objex we've created a Maven Archetype for an Objex jar.
  So to create the project issue the following command ...
  
+--
TODO: Maven command
+--

  Once this is done we then need to get Roo working so that it picks up the
  base Objex classes and generates the plumbing. To do this run roo from the
  root of your project.
  
  Note: To get roo generating you need to copy the Objex roo generator
  jar and Objex annotations jar the your Spring Roo dist folder. This is 
  tal-objex-roo-addon-{Version}.jar and tal-objex-annotation-{Version}.jar. 
  
  If your using Eclipse (or variant) you will probably want to mark the 
  project as having the AspectJ nature.

** Step 2 - Create the State Beans

  Objex enforces a clear separation between the persisted state of our objects
  from the behaviour. It does this so we can very easily change persistence
  strategies to match our needs and runtime environment without affecting the
  behaviour. 
  
  So this means we must create what I call state beans. In practice these are
  simple JavaBean classes with private member variables for each property of
  the object. We must implement an interface for the state bean called
  ObjexObjStateBean, but this along with the getters and setters is done for
  us by the generators. So all you need to do is as follows:
  
+--
package your.namespace.beans;

// Imports omitted

@ObjexStateBean(name="OrderItem")
public class OrderItemBean {
    private final static long serialVersionUID = 1L;

	private String ref;
	private String name;
	private String description;
	private double quantity;
	private String measure;
	private double price;
	private String currency;
}
+--

  The magic happens by marking the object with the annotation above and Roo
  (if running) will pick it up and process it. You will get any number of
  AspectJ ITD files, which you can inspect to see what is generated.
  
  Note: If you have a property called id or parentId you may clash with
  automatically generated entries so best to leave these as reserved.
  
  So this will create an OrderItem, which roughly corresponds to every line
  in the order. We also need to OrderBean for the overall order. This needs
  to reference the OrderItems it is part of ...
  
+--
@ObjexStateBean(name="Order")
public class OrderBean {
    private static final long serialVersionUID = 1L;

    private long account;
    @ObjexRefProp(owned=true, type=ObjexObj.class, newType="OrderItem")
    private List<String> items;
}
+--

  So in addition to the simple scalar account field we also have a list.
  This list will hold a list of strings. In reality it actually holds ObjexID
  references, however, ObjexID are always stringifiable and various different
  DB technologies recognise Strings natively as opposed to ObjexID so we 
  generally simply reference them as strings in the bean objects.
  
  Note: In a later version of Objex I would like to strengthen this.
  
  The key is the @ObjexRefProp annotation. This tells the generator that
  it actually represents a reference property, in this case a List of
  references. The parameters are interesting here:
  
    owned - Tells the generator that this reference represents child objects
    (as opposed to simple references). In simple terms this means it will
    generate create methods for the property in the ObjexObj (Step 3), but
    there are other implications.
    
    type - This tells us what type we expect each entry to actually be. It
    will always be an ObjexObj so that is safe, but we could use an interface
    of our own choosing if we so preferred.
    
    newType - The optional parameter gives us the type of object to create
    when adding to this list. If it is not supplied (because it could be one
    of many types) then the create methods on the ObjexObj will take in an
    additional type parameters.
    
  You can also have non-list reference properties (these should be typed as
  a String) and Maps.
  
  If Roo is running you should now have two state beans each with various
  getter/setters and a few other methods required by Objex. You should write
  a unit test for the bean just to make sure all the getter/setters work etc.
  
** Step 3 - Create the ObjexObj Classes

  OK, so we've generated our beans. Now we need to define the actual objects
  that contain our behaviour. These will implement the ObjexObj interface.
  Again we have generators for these classes so ...
  
+--
package your.package.model;

@ObjexObj(OrderItemBean.class)
public class OrderItemImpl implements OrderItem {

    private final OrderItemBean bean;
    
    public OrderItemImpl(OrderItemBean bean) {
        this.bean = bean;
    }
}
+--

  In fairness even the bean member variable could have been generated, but
  then it would have been difficult for you to write any behaviour as you
  would not have access to the state of your object because the ITDs inject
  everything in.
  
  You will notice here that I've actually implemented an interface. I believe
  very strongly in having an interface to everything so although I've not
  shown the interface in the example I think you should always create an
  interface that the outside world see's.
  
  No prizes for guessing the Order object...
  
+--
@ObjexObj(OrderBean.class)
public class OrderImpl implements Order {
    
    private final OrderBean bean;
    
    public OrderImpl(OrderBean bean) {
        this.bean = bean;
    }
}
+--

  As long as Roo is running we now have our persistable state beans and now
  the shell of our behaviour beans. We havn't actually added any custom
  behaviour yet, but the shell is there to do that. 

** Step 4 - Describe the Container

  There is no need to implement the Container interface. There is a standard
  implementation of Container inside the core, but to use that we do need to
  provide a simple description of our container and the objects. This is done
  by providing an instance of the ContainerStrategy interface, which in turn
  holds an ObjectStrategy instance for each object type in the container.
  
  I typically use Spring so I would use a Spring configuration, but it can
  be done programmatically as well.
  
+--
TODO: Spring config for a container
+--

** Step 5 - Test the Container

  In order to test the container if we are using the default Container 
  implementation we must provide a runtime environment. The runtime environment
  provides a bridge between the Objex world and any data storage. Objex
  calls this bridge the middleware.
  
  There is a test implementation of the middleware interface that simply
  holds the state beans of a container in memory. So we will use this. To
  connect the test middleware to the container we define a ContainerFactory.
  The following Spring snippet shows this - again if you want to do this
  programmatically you can ...
  
+--
TODO: Spring Config for a middleware
+--

  The other projects inside Objex are runtime environments. We have or are
  working on ...
  
    [[]] XML File Based Middleware
    
    [[]] JDO Based DB Middleware (I will consider a JPA one as well)
    
    [[]] Google App Engine Middleware
    
    [[]] Amazon AWS Simple DB Middleware
    
  In addition there are also middlewares or adaptors for the storing BLOB 
  objects and sending asynchronous events - these are not described on this
  page.
  
  Now you can write a test - I'll leave that to you, but the sample inside
  the Objex distribution has some. Of course now you've done it you'll
  write your tests first going forward :)
  
** Step 6 - Adding Custom Service/Repository Interfaces

  It is very important to me that the use of Objex is an implementation detail
  and is not directly exposed to the clients. You might take a view that you
  will expose it, but that needs to be your choice. So the final part of the
  example shows how you can do just that.
  
  Although I didn't show the code we've already added custom interfaces to
  our ObjexObj classes, OrderItem and Order. Typically these will be defined
  in a separate API package/project. In the sample that comes with Objex you
  can see this as a separate project that has no dependencies on Objex at all.
  
  So the final step is to provide access to the container. For this I will
  create a Service and a Repository interface. This shows how Objex can be
  used to create a domain where a fairly common design pattern would be to 
  expose a service that gives you the repository and a repository that provides
  access to the objects via various findBy methods.
  
  TODO: The examples are in the sample project, but I've need to complete this
  page.
  
** Next Steps

  So we now have a simple Order domain represented as an Objex document. We will
  have (hopefully) many instances of this container in our live application.
  
  What now ...
  
  Well first off we havn't implemented any behaviour so back in our ObjexObj
  we need to implement that. Behaviour comes in various forms. It might be that
  when you change the value of one field another field changes value, or it
  might be we expose certain operations methods on the interface we need to
  implement.
  
  Second off we need to implement validation on the objects. Validation is 
  covered off in its own page.
  
  And finally you'll want to extend this domain with other objects for instance,
  details of the customer, the delivery address, payment or other invoice data
  etc, etc. Sit down and discuss that with the real users. 